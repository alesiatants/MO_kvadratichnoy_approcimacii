// Метод_квадратичной_аппроксимации_Пауэлла.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <cmath>
#include <conio.h>
#include <clocale>
using namespace std;
//целевая функция
double f(double x) {
    return (200 / x) + ((9 * x) / 2);
}
//находим fmin и точку xmin, соответствующую fmin
double min(double y1, double y2, double y3, double x1, double x2, double x3, double& xmin) {
    double y;
    y = y1; xmin = x1;
    if (y > y2) {
        y = y2; xmin = x2;
    }
    if (y > y3) {
        y = y3; xmin = x3;
    }
    return y;
}
//определяем коэффициенты полинома и возвращаем точку минимума полинома второго порядка
double polinom(double x1, double x2, double x3, double y1, double y2, double y3) {
    double a1, a2;
    a1 = (y2 - y1) / (x2 - x1);
    a2 = ((y3 - y1) / (x3 - x1) - a1) / (x3 - x2);
    return (x2 + x1) / 2 - a1 / (2 * a2);
}
int main()
{
    setlocale(LC_ALL, "Russian");
    //объявление основных переменных
    double dx, eps1, eps2;
    //объявление вспомагательных переменных
    double x1, y1, x2, y2, x3, y3;
    double xmin, fmin, xc, fc, x;
    int k=0;
    cout << "Расчет оптимального решения задачи\n";
    cout << "Введите начальную точку x1 =";
    cin >> x1;
    cout << "Введите шаг dx =";
    cin >> dx;
    cout << "Введите точность поиска eps1 =";
    cin >> eps1;
    cout << "Введите точность поиска eps2 =";
    cin >> eps2;
    //Вычисляем точку х2
    x2 = x1 + dx;
    //определяем значение целевой функции в точках x1 и x2
    y1 = f(x1);
    y2 = f(x2);
    //если функция убывает в точке x2, то продвигаемся вправо на удвоенных шаг и определяем точку x3
    if (y1 > y2) x3 = x1 + 2 * dx;
    //если функция djphfcnftn в точке x2, то продвигаемся влево на  шаг и определяем точку x3
    else x3 = x1 - dx;
    //находим значение целевой функции в точке x3
    y3 = f(x3);

    do {
        //Определяем минимальное значение целевой функции fmin из предложенных и значение точки xmin соответствующей fmin
        fmin = min(y1, y2, y3, x1, x2, x3, xmin);
        //находим точку минимума полинома второго порядка
        xc = polinom(x1, x2, x3, y1, y2, y3);
        //определяем значение целевой функции в полученной ранее точке минимума
        fc = f(xc);
        //выбираем наилучшую точку
        if (fmin < fc)x = xmin;
        else x = xc;
        //Выбираем две точки слева и справа от наилучшей точки х
        if ((x >= x1) && (x <= x2)) {
            x3 = x2;
            x2 = x;
            y3 = y2;
        }
        else {
            x1 = x2;
            x2 = x;
            y1 = y2;
        }
        //вычисляем значение целевой функции в точке х2
        y2 = f(x2);
        k++;
        cout << "k = " << k << " xc = " << xc << " fc = " << fc << endl;
    } while ((fabs((xmin - xc) / xc) > eps2) || (fabs((fmin - fc) / xc) > eps1));//условие окончания процесса вычисления
    cout << "Оптимальный размер стержня x = " << xc << " при минимизированной силе, приложенной к краю стержня f = " << fc;

}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
